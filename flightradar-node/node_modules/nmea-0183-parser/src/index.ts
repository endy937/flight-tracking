import * as pkg from '../package.json';
import utils from "./utils";
import * as moment from "moment-timezone";
import hooks from './hooks';

class Parser {
    options: any;
    session: any;
    name: string;
    version: string;
    author: string;
    license: string;
    hooks: any;
    constructor(
        opts = {
            emitPropertyValue: () => undefined,
            onPropertyValues: (a: string, b: any) => undefined,
        }) {
        this.options = typeof opts === 'object' && opts !== null ? opts : {}
        if (!Object.keys(this.options).includes('validateChecksum')) {
            this.options.validateChecksum = true
        }
        this.session = {}

        this.name = pkg.name
        this.version = pkg.version
        this.author = pkg.author
        this.license = pkg.license
        console.log(hooks);
        this.hooks = { ...hooks }

        opts.onPropertyValues &&
            opts.onPropertyValues('nmea0183sentenceParser', (propertyValues_: any) => {
                if (propertyValues_ === undefined) {
                    return
                }
                const propValues = propertyValues_
                    .filter((v: any) => v)
                    .map((propValue: { value: any; }) => propValue.value)
                    .filter(isValidSentenceParserEntry)
                    .map(({ sentence, parser }: any) => {
                        console.debug(`setting custom parser ${sentence}`)
                        this.hooks[sentence] = parser
                    })
            })
    }

    parse(sentence: string) {
        let tags: any = getTagBlock(sentence)

        if (tags !== false) {
            sentence = tags.sentence
            tags = tags.tags
        } else {
            tags = {}
        }

        let valid = utils.valid(sentence, this.options.validateChecksum)

        if (valid === false) {
            throw new Error(`Sentence "${sentence.trim()}" is invalid`)
        }

        if (sentence.charCodeAt(sentence.length - 1) === 10) {
            // in case there's a newline
            sentence = sentence.substr(0, sentence.length - 1)
        }

        const data = sentence.split('*')[0]
        const dataParts = data.split(',')
        let id = ''
        let talker = ''
        let internalId = ''

        if (dataParts[0].charAt(1).toUpperCase() === 'P') {
            // proprietary sentence
            id = dataParts[0].substr(-3, dataParts[0].length).toUpperCase()
            talker = dataParts[0].substr(1, 2).toUpperCase()
            internalId = dataParts[0].substr(1, dataParts[0].length)
        } else {
            id = dataParts[0].substr(3, 3).toUpperCase()
            talker = dataParts[0].substr(1, 2)
            internalId = id
        }
        const split = dataParts.slice(1, dataParts.length)

        if (typeof tags.source === 'undefined') {
            tags.source = ':'
        } else {
            tags.source = `${tags.source}:${id}`
        }

        if (typeof this.hooks[internalId] === 'function') {
            const result = this.hooks[internalId](
                {
                    id,
                    sentence,
                    parts: split,
                    tags,
                },
                this.session
            )
            return transformSource(result, id, talker)
        } else {
            return null
        }
    }
}

function isValidSentenceParserEntry(entry: { sentence: any; parser: any; }) {
    const isValid =
        typeof entry.sentence === 'string' && typeof entry.parser === 'function'
    if (!isValid) {
        console.error(`Invalid sentence parser entry:${JSON.stringify(entry)}`)
    }
    return isValid
}

function transformSource(data: any, sentence: any, talker: any) {
    if (typeof data !== 'object' || data === null) {
        return data
    }

    if (!Array.isArray(data.updates)) {
        return data
    }

    data.updates = data.updates.map((update: any) => {
        if (typeof update.source === 'object' && update.source !== null) {
            return update
        }

        const _source = update.source || ''
        const tagSentence = _source.split(':')[1]
        let tagTalker = _source.split(':')[0]

        if (talker === 'nmea0183') {
            talker = 'SK'
        }

        update.source = {
            sentence: tagSentence || sentence,
            talker: tagTalker || talker,
            type: 'NMEA0183',
        }

        return update
    })

    return data
}

function getTagBlock(sentence: string) {
    let split: any[] = []
    let block = []
    let tags: any = {}

    // There could be a tag block...
    if (sentence.charAt(0) === '\\') {
        split = sentence.split('\\')
        split = split.filter((part) => {
            if (part.trim() === '') {
                return false
            }
            return true
        })
    }

    if (split.length < 2) {
        return false
    }

    if (split[1].trim().charAt(0) === '$' || split[1].trim().charAt(0) === '!') {
        sentence = split[1].trim()
        block = split[0].trim().split(',')
    }

    block.forEach((t: any) => {
        if (t.indexOf('c:') !== -1) {
            tags.timestamp = parseInt(t.replace('c:', '').split('*')[0], 10)
        }

        if (t.indexOf('s:') !== -1) {
            tags.source = t.replace('s:', '')
        }
    })

    if (typeof tags.timestamp === 'number') {
        let len = String(tags.timestamp).length

        if (len <= 12) {
            tags.timestamp *= 1000
        }

        tags.timestamp = moment.tz(tags.timestamp, 'UTC').toISOString()
    }

    return {
        sentence,
        tags,
    }
}

export default Parser


